title: 「JavaScript高级程序设计」面向对象的程序设计
date: 2015-01-13 11:32:17
tags: [JavaScript, 阅读笔记]
---
##  面向对象的程序设计

#  前言
- 面向对象(OO)，那就是它们都有类的概念。而且通过类可以创建任意多个属性和方法对象。
- ECMAScript中没有类的概念。每个对象基于一个引用类型创建的。内部由键值对组成。

6.1  理解对象
- 最简单的方式就是创建一个Object实例，然后为其添加属性和方法。
    ![1.jpg](/img/imgs-books/1.jpg)
   
6.1.1  属性类型
- ECMAScript中有两种属性类型：数据属性和访问器属性。
    - 数据属性（在IE8中不要使用，只支持在DOM对象上使用。）
        - [[Configurable]]：默认为true，表示能够通过delete删除。
        - [[Enumerable]]：默认为true，表示能否通过for-in循环遍历。
        - [[Writable]]：默认为true，表示能否修改属性值。
        - [[Value]]：默认为true，表示属性默认值。
        - 以上属性可以通过Object.defineProperty()进行修改。如下：
            ![2.jpg](/img/imgs-books/2.jpg)
    - 访问器属性
        - 需要有一对get，set函数，在读取访问器属性时，会调用get并返回有效的值。在写入访问器属性时，会调用set函数并传入新值。
        - [[configurable]]：默认值为true，表示是否可以通过delete删除属性。
        - [[enumerable]]：默认值为true，表示能否通过for-in循环遍历。
        - [[get]]：默认值为undefined，在读取属性时调用的函数。
        - [[set]]：默认值为undefined，在写入属性时调用的函数。
            ![3.jpg](/img/imgs-books/3.jpg)      
6.1.2  定义多个属性
6.1.3  读取属性的特性

6.2  创建对象
- 虽然Object构造函数或者对象字面量都可以用来创建单个对象。但是有个明显的缺点：使用同一个接口创建人多对象，会产生大量的重复代码。

6.2.1  工厂模式
- 用函数来封装特定接口，用于创建对象。如下：
    ![4.jpg](/img/imgs-books/4.jpg)

6.2.2  构造函数模式
- 通过new关键字来创建对象。内部属性与方法通过this绑定。如下：
    ![5.jpg](/img/imgs-books/5.jpg)
- 我们可以通过instanceof来监测p是否是Person的实例。

6.2.3  原型模式
- 每个一个函数都有一个prototype的属性。这个属性是一个指针，会指向一个对象。这个对象包含实例上所有的属性和方法。如下：
    ![6.jpg](/img/imgs-books/6.jpg)
    - 理解原型对象
        - 当创建一个新的函数时，该函数会对应有一个自由属性prototype，用于原型链扩展。
        - prototype下的constructor指向函数自身。
        - 如果通过new关键字对函数进行了构建，那么函数的引用会有一个__proto__方法，它会指向这个函数的prototype。
        - 可以通过hasOwnProperty()来验证属性是否属于函数的自有属性或原型链属性。
        - 可以通过isPrototype()方法来判断引用对象是否属于某个函数原型。
        - 在ECMA5中可以通过Object.getPrototypeOf()检测引用对象是否属于函数原型。如下：
            ![7.jpg](/img/imgs-books/7.jpg)
    - 原型与in操作符
        - 可以通过in关键字来判断属性是否属于实例或者原型链。
            ![8.jpg](/img/imgs-books/8.jpg)
    - 更简单的原型语法
        - 如果要在prototype上绑定多个属性或方法，可以通过字面量的方式重写原型对象。
            ![9jpg](/img/imgs-books/9.jpg)
    - 原型的动态性
        - 实例引用与原型链之间的松散连接。根据指针动态查找，如果实例中没有，会继续在原型链中查找。
        - 如果通过字面量的方式将prototype重写，那么相当于切断了构造函数与最初原型链的联系。
            ![10.jpg](/img/imgs-books/10.jpg)
    - 原生对象的原型
        - 所有的原生的引用类型，都是采用原型链的模式。如：Object、Array、String。
            ![11.jpg](/img/imgs-books/11.jpg)
    - 原型对象的问题
        - 如果原型链中包含引用类型的属性，那么实例化将共享这个属性。
            ![12.jpg](/img/imgs-books/12.jpg)

6.2.4  组合使用构造函数模式和原型模式
    - 构造函数模式与原型模式是最常见的方式。
    - 构造函数用于定义实例自有属性。
    - 原型模式用于定义方法和共享的属性。
        ![13.jpg](/img/imgs-books/13.jpg)

6.2.5  动态原型模式
- 在函数中检查某个方法是否有效，从而决定是否需要初始化原型。
    ![14.jpg](/img/imgs-books/14.jpg)

6.2.6  寄生构造函数模式
- 寄生构造函数返回的对象与构造函数的原型属性没有关系。
- 外部通过new关键字创建的寄生构造函数不能通过instanceof来判断对象类型。因为在函数内部寄生依赖并return了另外一个构造函数对象。
- 与工厂模式唯一的区别是外部构造函数使用new关键字。
    ![15.jpg](/img/imgs-books/15.jpg)

6.2.7  稳妥构造函数模式
- 创建对象的实例方法中不能引用this。
- 不使用new关键字调用构造函数。
    ![16.png](/img/imgs-books/16.png)

6.3  继承
- 许多OO语言都支持两种继承方式：接口继承和实现继承。
- ECMAScript只支持实现继承，继承机制是依靠原型链来实现的。

6.3.1  原型链
- 原型链继承的主要方法是：利用原型让一个引用类型继承另一个引用类型的属性和方法。
    ![17.png](/img/imgs-books/17.png)
    - 别忘记默认的原型
        - 引用类型默认都继承于Object，并且也是通过prototype原型链实现的。
        - 当调用一个原型链的属性或者方法时，查找方式会逐级向上冒泡式的查找，一直查找到Object.prototype上，如果没有会返回undefined。
    - 确定原型和实例的关系
        - 确定原型和实例之间关系有两种方式：
            - p instanceof Person    // true
            - Person.pertotype.isPrototypeOf(p)    // true
    - 谨慎地定义方法
        - 如果子类要继承并覆盖父类中的某个属性或方法，给子类添加原型方法时一定要放在替换原型（子继承父）之后。
            ![18.png](/img/imgs-books/18.png)
    - 原型链的问题
        - 引用类型的原型属性会被所有实例共享。
        - 在创建子类的实例时，不能向超类的构造函数中传递参数。

6.3.2  借用构造函数
- 在子类的构造函数的内部调用超类的构造函数。
- 通过apply(thisArgs, [argsArray])和call(thisArgs, [arg1, arg2...])改变作用域同时传递参数式调用。

6.3.3  组合继承
- 结合原型链与借用构造函数。
- 组合继承避免了原型链共享的问题，并且可以通过instanceof和isPrototypeOf来识别组合继承的对象。
   ![19.jpg](/img/imgs-books/19.jpg)

6.3.4  原型式继承
- 由道格拉斯提出的，借助原型可以基于已有的对象创建新的对象。
- 如下，形参o是一个字面量对象，因为它是引用类型，所以当他赋值给F的原型链后，当F被实例化，o自然拥有F.prototype的属性及其方法。
    ![20.jpg](/img/imgs-books/20.jpg)
- 在ECMAScript5中新增了Object.create()方法，规范化了原型式继承。
- Object.create()接受两个参数，第一个是要用于创建原型的对象(一般为字面量)，另一个是可选参数，表示一个要创建的这个原型对象的额外属性值。
    ![21.jpg](/img/imgs-books/21.jpg)

6.3.5  寄生式继承
- 寄生式继承的思路与寄生构造函数和工厂模式类似。

6.3.6  寄生组合式继承？